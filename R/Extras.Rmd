---
title: "Tidyverse Programming Extras"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gapminder)
options(dplyr.summarise.inform = FALSE)
```

## What about with multiple data variables?

> #### SOLUTION A - Pass the dots `(…)`

```{r pass_the_dots}
#The dots are the last input parameter in the function call
grouped_mean_dots <- function(data, summary_column, ...) {
  data %>%
    group_by(...) %>%
    summarise("mean_{{summary_column}}" := mean({{ summary_column }}, na.rm = T))
}

grouped_mean_dots(gapminder, pop, continent, year)
#Can also pass single inputs to (...)
grouped_mean_dots(gapminder, pop, continent)

# Careful with string input vs data variables
# What is this doing?
grouped_mean_dots(gapminder, pop, "continent", "year")
#c.f.
mean(gapminder$pop)
```

-   Note that using `(…)` perpetuates NSE/Data-masking to your bespoke
    function.

-   NOTE HOWEVER - you can only pass one set of inputs to the (...) - so
    you can't use it to specify group variables *and* summary variables!

> #### SOLUTION B - use across()

```{r multi_gps_across}
gap_means <- function(data, grouping_variables, summary_columns){
  data %>% 
    group_by(across({{ grouping_variables }})) %>% 
    summarise(across({{ summary_columns }}, ~ mean(., na.rm = T))) 
}

gap_means(gapminder, c(country, year), c(lifeExp, pop, gdpPercap))

#Or combined across() with (...) - here the dots need to be encased in c()
my_mean <- function(data, ...) {
  data %>% 
    summarise(across(c(...), ~ mean(.x, na.rm = TRUE)))
}

gapminder %>% my_mean(lifeExp, pop)
gapminder %>% my_mean(starts_with("p"))

```

#### For the above - name the columns with `.names = ""`

use `.names = ""` when there are multiple variables (`:=` only works
with single variables)

```{r multi_gps_naming}
# Use the .names = "" option 
gap_mean_name_multicols <- function(data, grouping_variable, summary_columns) {
  data %>% 
    group_by(across({{grouping_variable}})) %>% 
    summarise(across({{ summary_columns }}, 
                     ~ mean(., na.rm = TRUE), 
                     .names = "mean_{.col}"))
}

gap_mean_name_multicols(gapminder, c(continent, year), c(lifeExp, pop, gdpPercap))

```

> #### SOLUTION C - for STRING INPUT can use string vector helpers: 
> `all_of()` / `any_of()`. 
>
> When we have a vector of string inputs we can't use the `.data[[ ]]`
> trick we used for single string input. The `.data` pronoun can only be
> sub-setted with single column names. It doesn't support single-bracket
> indexing (i.e. .`data[ ]`). Instead we can use `all_of()` or `any_of()`. 
>  - `all_of()` acts on all of the columns listed (they must all exist).
>  - `any_of()` acts on all of the columns listed, if they exist, and ignores
> missing ones.

```{r strings_helper_funs}
slice_stringinputs_multgps <- function(data, grouping_variable, columns, row_start, row_end) {
  data %>% 
    group_by(across(all_of(grouping_variable))) %>% 
    select(all_of(columns)) %>% 
    slice(row_start:row_end)
}
slice_stringinputs_multgps(gapminder, c("continent", "country"), c("pop", "lifeExp"), 1, 3)

```
```{r strings_any_of}
slice_stringinputs_multgps <- function(data, grouping_variable, columns, row_start, row_end) {
  data %>% 
    group_by(across(any_of(grouping_variable))) %>% 
    select(any_of(columns)) %>% 
    slice(row_start:row_end)
}
slice_stringinputs_multgps(gapminder, c("continent", "country", "missing"), c("deleted", "pop", "lifeExp"), 1, 3)

```

## Do you even need Tidy Eval?

#### Not if you can assume fixed column names in data!

-   Need to add checks on inputs (column existence, scale of values) in
    the function

```{r fixed_col_names}
# Calculate lifeExp / pop (a contrived example)

life_v_pop <- function(data){
  if(all(c("lifeExp", "pop") %in% names(data))) {
    data %>% mutate(life_v_pop = lifeExp / pop)
  
  } else {
    stop("dataset must contain columns named `lifeExp` and `pop`")
  }
}
  
life_v_pop(gapminder)
life_v_pop(mtcars)
```

#### Not if you can use column-wise mapping functions (scoped dplyr verbs)

-   Scoped verbs for `mutate_` / `summarise_` / `filter_` / `group_by_`

    -   `_all` --\> map over all columns

    -   `_if` --\> map over columns selected by condition

    -   `_at` --\> map over a custom selection

    -   No data masking = take objects (not blueprints)

```{r nonNSE_function_alternatives}
#Scale all numeric variables by SD (function will work on any dataset)
my_scale <- function(data){
  data %>% mutate_if(is.numeric, ~. / sd(.))
}
my_scale(gapminder)
my_scale(mtcars)
# Don't necessarily need to wrap in a function...
iris %>% mutate_if(is.numeric, ~. / sd(.))

#E.g. get mean of all numeric cols by all grouping variables
my_gp_summarise <- function(data){
  data %>% 
    group_by_if(is.factor) %>% 
    summarise_if(is.numeric, mean)
}
#work on any dataset
my_gp_summarise(gapminder)
my_gp_summarise(mtcars)

#Can use string vectors directly
my_summarise <- function(data, vars){
  data %>% summarise_at(vars, mean)
}
my_summarise(gapminder, c("lifeExp", "pop"))

```

------------------------------------------------------------------------

### Do we ever need for loops?

We might naively try to summarise two columns in a for loop:

```{r for_loop}
columns <- names(gapminder)[4:6]
out <- rep(list(NULL), 3)
for(col in seq_along(columns)){
  out[[col]] <- gapminder %>%
    summarise(mean = mean(columns[[col]], na.rm = T))
}
unlist(out)
```

It doesn't work because `columns[[col]]`, a string representing the name
of a column in gapminder, is not recognised as a data variable within
the context of the `mean` function. Now we can try again using the
`.data` pronoun.

```{r for_loop_solved}
columns <- names(gapminder)[4:6]
out <- rep(list(NULL), 3)
for(col in columns){
  out[[col]] <- gapminder %>%
    summarise(mean = mean(.data[[col]]))
}
unlist(out)
```

It worked but it's ugly and we have an awkward output format. We can
improve this by using the tidy selection function `across` to drop the
for loop:

```{r for_loop_replaced}
columns <- names(gapminder)[4:6]
gapminder %>%
  summarise(across(all_of(columns), mean))
# or, if we have parameters, use a dot to represent the current variable
gapminder %>%
    summarise(across(all_of(columns), ~mean(., na.rm = T)))
```

> This actually means that for loops are rarely needed!

## Using tidy evaluation in other {tidyverse} package functions: ggplot

Finally, we can apply this same logic to other {tidyverse} package
functions.

-   either embrace `{{ }}` the data variable names

```{r ggplot_NSE_functions}
scatter_plot <- function(data_frame, x_axis, y_axis ) {
  ggplot(data_frame, aes(x = {{ x_axis }}, y = {{ y_axis }})) +
    geom_point(alpha = 0.5)
}

gapminder %>%
  gap_mean_name(year, lifeExp) %>%
  scatter_plot(year, mean_lifeExp)

gapminder %>%
  gap_mean_name(continent, gdpPercap) %>%
  scatter_plot(continent, mean_gdpPercap)
```

-   or subset the data using `.data[[ ]]` and input strings to the
    function call

```{r}
scatter_plot <- function(data_frame, x_axis, y_axis ) {
  ggplot(data_frame, aes(x = .data[[x_axis]], y = .data[[y_axis]])) +
    geom_point(alpha = 0.5)
}

gapminder %>%
  gap_mean_name(continent, gdpPercap) %>%
  scatter_plot("continent", "mean_gdpPercap")
```

-   or pass the dots `(…)` - can pass the dots to `aes()` or `vars()`

```{r ggplot_pass_the_dots}
scatter_facet_plot <- function(data_frame, x_axis, y_axis, ...) {
  ggplot(data_frame, aes(x = {{ x_axis }}, y = {{ y_axis }})) +
    geom_point(alpha = 0.5) +
    facet_wrap(vars(...))
}

gapminder %>% 
  grouped_mean_dots(lifeExp, continent, year) %>% 
  scatter_facet_plot(x_axis = year, y_axis = mean_lifeExp, continent)
```
